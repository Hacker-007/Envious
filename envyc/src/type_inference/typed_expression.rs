use std::rc::Rc;

use crate::{
    error::Span,
    parser::expression::{BinaryOperation, UnaryOperation},
    type_inference::monotype::Monotype,
};

use super::monotype::MonotypeRef;

/// Represents an expression that is generated by the `Parser`.
/// Each expression consists of a span (the location information of the expression)
/// and the kind of the expression.
pub type TypedExpression<'a> = (Span<'a>, TypedExpressionKind<'a>);

/// Enum that details the different types of expressions that can be produced
/// by the `Expression`. The `ExpressionKind` should strive to only store types that
/// are small in nature and any other types (i.e. String) should be stored in the
/// `Interner`.
#[derive(Debug)]
pub enum TypedExpressionKind<'a> {
    Int(MonotypeRef, i64),
    Float(MonotypeRef, f64),
    Boolean(MonotypeRef, bool),
    Char(MonotypeRef, char),
    // The actual value for the `Identifier` are
    // stored in the `Interner` to reduce redundency in values. Instead,
    // the id's are stored in the variant.
    Identifier(TypedIdentifier),
    Unary(TypedUnary<'a>),
    Binary(TypedBinary<'a>),
    If(TypedIf<'a>),
    Let(TypedLet<'a>),
    Block(Vec<TypedExpression<'a>>),
    Application(TypedApplication<'a>),
    While(TypedWhile<'a>),
    Return(Option<Box<TypedExpression<'a>>>),
}

impl<'a> TypedExpressionKind<'a> {
    pub fn get_type(&self) -> MonotypeRef {
        match self {
            TypedExpressionKind::Int(ty, _) => ty.clone(),
            TypedExpressionKind::Float(ty, _) => ty.clone(),
            TypedExpressionKind::Boolean(ty, _) => ty.clone(),
            TypedExpressionKind::Char(ty, _) => ty.clone(),
            TypedExpressionKind::Identifier(TypedIdentifier { id: _, ty }) => ty.clone(),
            TypedExpressionKind::Unary(TypedUnary {
                operation: _,
                expression: _,
                ty,
            }) => ty.clone(),
            TypedExpressionKind::Binary(TypedBinary {
                operation: _,
                left: _,
                right: _,
                ty,
            }) => ty.clone(),
            TypedExpressionKind::If(TypedIf {
                condition: _,
                then_branch: _,
                else_branch: _,
                ty,
            }) => ty.clone(),
            TypedExpressionKind::Let(TypedLet {
                name: _,
                given_type: _,
                expression: _,
                ty,
            }) => ty.clone(),
            TypedExpressionKind::Block(expressions) => expressions
                .last()
                .map(|expression| expression.1.get_type())
                .unwrap_or_else(|| Rc::new(Monotype::Void)),
            TypedExpressionKind::Application(TypedApplication {
                function_name: _,
                parameters: _,
                ty,
            }) => ty.clone(),
            TypedExpressionKind::While(_) => Rc::new(Monotype::Void),
            TypedExpressionKind::Return(value) => value.as_ref().map_or_else(
                || Rc::new(Monotype::Void),
                |expression| expression.1.get_type(),
            ),
        }
    }
}

#[derive(Debug)]
pub struct TypedIdentifier {
    pub id: usize,
    pub ty: MonotypeRef,
}

#[derive(Debug)]
pub struct TypedUnary<'a> {
    pub operation: UnaryOperation,
    pub expression: Box<TypedExpression<'a>>,
    pub ty: MonotypeRef,
}

#[derive(Debug)]
pub struct TypedBinary<'a> {
    pub operation: BinaryOperation,
    pub left: Box<TypedExpression<'a>>,
    pub right: Box<TypedExpression<'a>>,
    pub ty: MonotypeRef,
}

#[derive(Debug)]
pub struct TypedIf<'a> {
    pub condition: Box<TypedExpression<'a>>,
    pub then_branch: Box<TypedExpression<'a>>,
    pub else_branch: Option<Box<TypedExpression<'a>>>,
    pub ty: MonotypeRef,
}

#[derive(Debug)]
pub struct TypedLet<'a> {
    pub name: (Span<'a>, TypedIdentifier),
    pub given_type: Option<MonotypeRef>,
    pub expression: Box<TypedExpression<'a>>,
    pub ty: MonotypeRef,
}

#[derive(Debug)]
pub struct TypedApplication<'a> {
    pub function_name: (Span<'a>, TypedIdentifier),
    pub parameters: Vec<TypedExpression<'a>>,
    pub ty: MonotypeRef,
}

#[derive(Debug)]
pub struct TypedWhile<'a> {
    pub condition: Box<TypedExpression<'a>>,
    pub expression: Box<TypedExpression<'a>>,
}
