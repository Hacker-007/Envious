use crate::{
    error::Span,
    semantic_analyzer::types::Type
};

/// Represents an expression that is generated by the `Parser`.
/// Each expression consists of a span (the location information of the expression)
/// and the kind of the expression.
pub type Expression = (Span, ExpressionKind);

/// Enum that details the different types of expressions that can be produced
/// by the `Expression`. The `ExpressionKind` should strive to only store types that
/// are small in nature and any other types (i.e. String) should be stored in the
/// `Interner`.
#[derive(Debug)]
pub enum ExpressionKind {
    Int(i64),
    Float(f64),
    Boolean(bool),
    // The actual value for both the `String` and the `Identifier` are
    // stored in the `Interner` to reduce redundency in values. Instead,
    // the id's are stored in the variant.
    String(usize),
    Identifier(usize),
    Unary {
        operation: UnaryOperation,
        expression: Box<Expression>,
    },
    Binary {
        operation: BinaryOperation,
        left: Box<Expression>,
        right: Box<Expression>,
    },
    If {
        condition: Box<Expression>,
        then_branch: Box<Expression>,
        else_branch: Option<Box<Expression>>,
    },
    Let {
        name: (Span, usize),
        given_type: Option<Type>,
        expression: Box<Expression>,
    },
}

/// Enum that details the different unary operations
/// that can be applied to any expression.
/// Note that this enum should not contain any subexpressions.
/// It should exist to only describe the operations possible.
#[derive(Debug, Clone, Copy)]
pub enum UnaryOperation {
    Plus,
    Minus,
    Not,
}

impl UnaryOperation {
    pub fn get_name(&self) -> String {
        match self {
            UnaryOperation::Plus => "u+",
            UnaryOperation::Minus => "u-",
            UnaryOperation::Not => "unot"
        }.to_string()
    }
}

/// Enum that details the different binary operations
/// that can be applied to any expression.
/// Note that this enum should not contain any subexpressions.
/// It should exist to only describe the operations possible.
#[derive(Debug, Clone, Copy)]
pub enum BinaryOperation {
    Plus,
    Minus,
    Multiply,
    Divide,
}

impl BinaryOperation {
    pub fn get_name(&self) -> String {
        match self {
            BinaryOperation::Plus => "b+",
            BinaryOperation::Minus => "b-",
            BinaryOperation::Multiply => "b*",
            BinaryOperation::Divide => "b/",
        }.to_string()
    }
}